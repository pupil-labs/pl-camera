{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pupil Labs Camera","text":"<p>This repo contains functionality around the usage of camera intrinsics for undistorting data, and projecting and unprojecting points.</p> <p>It is mostly a wrapper around OpenCV's functionality, providing type hints, input validation, a more intuitive interface, and some changes to improve computational performance.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pupil-labs-camera\n</code></pre> <p>or</p> <pre><code>pip install -e git+https://github.com/pupil-labs/pl-camera.git\n</code></pre>"},{"location":"contributing/","title":"Developer","text":""},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Pupil Labs GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"modules/","title":"API reference","text":""},{"location":"modules/#pupil_labs.camera","title":"camera","text":"<p>Top-level entry-point for the pupil_labs.camera package</p> <p>Modules:</p> <ul> <li> <code>radial</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Camera</code>           \u2013            </li> </ul>"},{"location":"modules/#pupil_labs.camera.Camera","title":"Camera","text":"<pre><code>Camera(pixel_width: int, pixel_height: int, camera_matrix: CameraMatrixLike, distortion_coefficients: DistortionCoefficientsLike | None = None, use_optimal_camera_matrix: bool = False)\n</code></pre> <p>Methods:</p> <ul> <li> <code>distort_image</code>             \u2013              <p>Return an distorted image</p> </li> <li> <code>distort_points</code>             \u2013              <p>Distorts 2D image points using the camera's intrinsics.</p> </li> <li> <code>project_points</code>             \u2013              <p>Projects 3D points onto the 2D image plane using the camera's intrinsics.</p> </li> <li> <code>undistort_image</code>             \u2013              <p>Return an undistorted image</p> </li> <li> <code>undistort_points</code>             \u2013              <p>Undistorts 2D image points using the camera's intrinsics.</p> </li> <li> <code>unproject_points</code>             \u2013              <p>Unprojects 2D image points to 3D space using the camera's intrinsics.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>optimal_camera_matrix</code>               (<code>CameraMatrix</code>)           \u2013            <p>The \"optimal\" camera matrix for undistorting images.</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def __init__(\n    self,\n    pixel_width: int,\n    pixel_height: int,\n    camera_matrix: CT.CameraMatrixLike,\n    distortion_coefficients: CT.DistortionCoefficientsLike | None = None,\n    use_optimal_camera_matrix: bool = False,\n):\n    self.pixel_width = pixel_width\n    self.pixel_height = pixel_height\n    self.camera_matrix = camera_matrix\n    self.distortion_coefficients = distortion_coefficients\n    self.use_optimal_camera_matrix = use_optimal_camera_matrix\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.optimal_camera_matrix","title":"optimal_camera_matrix  <code>cached</code> <code>property</code>","text":"<pre><code>optimal_camera_matrix: CameraMatrix\n</code></pre> <p>The \"optimal\" camera matrix for undistorting images.</p> <p>This method uses OpenCV's <code>getOptimalNewCameraMatrix</code> to calculate a new camera matrix that maximizes the retirval of sensible pixels in the undistortion process, while avoiding \"virtual\" black pixels stemming from outside the captured distorted image.</p>"},{"location":"modules/#pupil_labs.camera.Camera.distort_image","title":"distort_image","text":"<pre><code>distort_image(image: Image, use_optimal_camera_matrix: bool | None = None) -&gt; Image\n</code></pre> <p>Return an distorted image</p> <p>This implementation uses cv2.remap with a precomputed map, instead of cv2.undistort. This is significantly faster when undistorting multiple images because the undistortion maps are computed only once.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>Image array</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def distort_image(\n    self,\n    image: CT.Image,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Image:\n    \"\"\"Return an distorted image\n\n    This implementation uses cv2.remap with a precomputed map, instead of\n    cv2.undistort. This is significantly faster when undistorting multiple images\n    because the undistortion maps are computed only once.\n\n    Args:\n        image: Image array\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    map1, map2 = (\n        self._distort_rectify_map\n        if self._parse_use_optimal_camera_matrix(use_optimal_camera_matrix)\n        else self._distort_rectify_map\n    )\n\n    remapped: CT.Image = cv2.remap(\n        image,\n        map1,\n        map2,\n        interpolation=cv2.INTER_LINEAR,\n        borderValue=0,\n    )\n    return remapped\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.distort_points","title":"distort_points","text":"<pre><code>distort_points(points_2d: Points2DLike, use_optimal_camera_matrix: bool | None = None) -&gt; Points2D\n</code></pre> <p>Distorts 2D image points using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_2d</code>               (<code>Points2DLike</code>)           \u2013            <p>Array-like of 2D point(s) to be distorted.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def distort_points(\n    self,\n    points_2d: CT.Points2DLike,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Points2D:\n    \"\"\"Distorts 2D image points using the camera's intrinsics.\n\n    Args:\n        points_2d: Array-like of 2D point(s) to be distorted.\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    points_3d = self.unproject_points(\n        points_2d,\n        use_distortion=False,\n        use_optimal_camera_matrix=use_optimal_camera_matrix,\n    )\n    distorted_points = self.project_points(\n        points_3d,\n        use_distortion=True,\n        use_optimal_camera_matrix=use_optimal_camera_matrix,\n    )\n    return distorted_points\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.project_points","title":"project_points","text":"<pre><code>project_points(points_3d: Points3DLike, use_distortion: bool = True, use_optimal_camera_matrix: bool | None = None) -&gt; Points2D\n</code></pre> <p>Projects 3D points onto the 2D image plane using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_3d</code>               (<code>Points3DLike</code>)           \u2013            <p>Array of 3D point(s) to be projected.</p> </li> <li> <code>use_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies distortion using the camera's distortion coefficients. If False, ignores distortion.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def project_points(\n    self,\n    points_3d: CT.Points3DLike,\n    use_distortion: bool = True,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Points2D:\n    \"\"\"Projects 3D points onto the 2D image plane using the camera's intrinsics.\n\n    Args:\n        points_3d: Array of 3D point(s) to be projected.\n        use_distortion: If True, applies distortion using the camera's distortion\n            coefficients. If False, ignores distortion.\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    np_points_3d = to_np_point_array(points_3d, 3)\n    distortion_coefficients = self._get_distortion_coefficients(use_distortion)\n    camera_matrix = self._get_unprojection_camera_matrix(use_optimal_camera_matrix)\n\n    rvec = tvec = np.zeros((1, 1, 3))\n\n    projected_2d, _ = cast(\n        tuple[np.ndarray, np.ndarray],\n        cv2.projectPoints(\n            objectPoints=np_points_3d,\n            rvec=rvec,\n            tvec=tvec,\n            cameraMatrix=camera_matrix,\n            distCoeffs=distortion_coefficients,\n        ),\n    )\n    projected_2d = projected_2d[:, 0]\n    projected_2d = projected_2d.astype(np.float64)\n    if np_points_3d.ndim == 1:\n        return cast(CT.Points2D, projected_2d[0])\n\n    return projected_2d\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.undistort_image","title":"undistort_image","text":"<pre><code>undistort_image(image: Image, use_optimal_camera_matrix: bool | None = None) -&gt; Image\n</code></pre> <p>Return an undistorted image</p> <p>This implementation uses cv2.remap with a precomputed map, instead of cv2.undistort. This is significantly faster when undistorting multiple images because the undistortion maps are computed only once.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>Image array</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def undistort_image(\n    self,\n    image: CT.Image,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Image:\n    \"\"\"Return an undistorted image\n\n    This implementation uses cv2.remap with a precomputed map, instead of\n    cv2.undistort. This is significantly faster when undistorting multiple images\n    because the undistortion maps are computed only once.\n\n    Args:\n        image: Image array\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    map1, map2 = (\n        self._optimal_undistort_rectify_map\n        if self._parse_use_optimal_camera_matrix(use_optimal_camera_matrix)\n        else self._undistort_rectify_map\n    )\n\n    remapped: CT.Image = cv2.remap(\n        image,\n        map1,\n        map2,\n        interpolation=cv2.INTER_LINEAR,\n        borderValue=0,\n    )\n    return remapped\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.undistort_points","title":"undistort_points","text":"<pre><code>undistort_points(points_2d: Points2DLike, use_optimal_camera_matrix: bool | None = None) -&gt; Points2D\n</code></pre> <p>Undistorts 2D image points using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_2d</code>               (<code>Points2DLike</code>)           \u2013            <p>Array-like of 2D point(s) to be undistorted.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def undistort_points(\n    self,\n    points_2d: CT.Points2DLike,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Points2D:\n    \"\"\"Undistorts 2D image points using the camera's intrinsics.\n\n    Args:\n        points_2d: Array-like of 2D point(s) to be undistorted.\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    np_points_2d = to_np_point_array(points_2d, 2)\n    camera_matrix = self._get_unprojection_camera_matrix(use_optimal_camera_matrix)\n\n    undistorted_2d = cv2.undistortPoints(\n        src=np_points_2d,\n        cameraMatrix=camera_matrix,\n        distCoeffs=self.distortion_coefficients,\n        R=None,\n        P=camera_matrix,\n    )[:, 0]\n    if np_points_2d.ndim == 1:\n        return cast(CT.Points2D, undistorted_2d[0])\n\n    return undistorted_2d\n</code></pre>"},{"location":"modules/#pupil_labs.camera.Camera.unproject_points","title":"unproject_points","text":"<pre><code>unproject_points(points_2d: Points2DLike, use_distortion: bool = True, use_optimal_camera_matrix: bool | None = None) -&gt; Points3D\n</code></pre> <p>Unprojects 2D image points to 3D space using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_2d</code>               (<code>Points2DLike</code>)           \u2013            <p>Array-like of 2D point(s) to be unprojected.</p> </li> <li> <code>use_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies distortion correction using the camera's distortion coefficients. If False, ignores distortion correction.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True applies optimal camera matrix</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def unproject_points(\n    self,\n    points_2d: CT.Points2DLike,\n    use_distortion: bool = True,\n    use_optimal_camera_matrix: bool | None = None,\n) -&gt; CT.Points3D:\n    \"\"\"Unprojects 2D image points to 3D space using the camera's intrinsics.\n\n    Args:\n        points_2d: Array-like of 2D point(s) to be unprojected.\n        use_distortion: If True, applies distortion correction using the camera's\n            distortion coefficients. If False, ignores distortion correction.\n        use_optimal_camera_matrix: If True applies optimal camera matrix\n\n    \"\"\"\n    np_points_2d = to_np_point_array(points_2d, 2)\n    distortion_coefficients = self._get_distortion_coefficients(use_distortion)\n    camera_matrix = self._get_unprojection_camera_matrix(use_optimal_camera_matrix)\n\n    projected_3d = cv2.undistortPoints(\n        src=np_points_2d,\n        cameraMatrix=camera_matrix,\n        distCoeffs=distortion_coefficients,\n    )[:, 0]\n    projected_3d = cv2.convertPointsToHomogeneous(projected_3d)[:, 0]\n    projected_3d = projected_3d.astype(np.float64)\n    if np_points_2d.ndim == 1:\n        return cast(CT.Points3D, projected_3d[0])\n    return projected_3d\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}