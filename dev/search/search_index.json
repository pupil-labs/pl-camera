{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pupil Labs Camera","text":"<p>This repo contains functionality around the usage of camera intrinsics for undistorting data, and projecting and unprojecting points.</p> <p>It is mostly a wrapper around OpenCV's functionality, providing type hints, input validation, a more intuitive interface, and some changes to improve computational performance.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pupil-labs-camera\n</code></pre> <p>or</p> <pre><code>pip install -e git+https://github.com/pupil-labs/pl-camera.git\n</code></pre>"},{"location":"contributing/","title":"Developer","text":""},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Pupil Labs GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"modules/","title":"API reference","text":""},{"location":"modules/#pupil_labs.camera","title":"camera","text":"<p>Top-level entry-point for the pupil_labs.camera package</p> <p>Modules:</p> <ul> <li> <code>radial</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CameraRadial</code>           \u2013            </li> </ul>"},{"location":"modules/#pupil_labs.camera.CameraRadial","title":"CameraRadial","text":"<pre><code>CameraRadial(pixel_width: int, pixel_height: int, camera_matrix: CameraMatrix, distortion_coefficients: DistortionCoefficients | None = None)\n</code></pre> <p>Methods:</p> <ul> <li> <code>project_points</code>             \u2013              <p>Projects 3D points onto the 2D image plane using the camera's intrinsics.</p> </li> <li> <code>undistort_points</code>             \u2013              <p>Undistorts 2D image points using the camera's intrinsics.</p> </li> <li> <code>unproject_points</code>             \u2013              <p>Unprojects 2D image points to 3D space using the camera's intrinsics.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>optimal_camera_matrix</code>               (<code>CameraMatrix</code>)           \u2013            <p>The \"optimal\" camera matrix for undistorting images.</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def __init__(\n    self,\n    pixel_width: int,\n    pixel_height: int,\n    camera_matrix: CT.CameraMatrix,\n    distortion_coefficients: CT.DistortionCoefficients | None = None,\n):\n    self.pixel_width = pixel_width\n    self.pixel_height = pixel_height\n    self.camera_matrix = camera_matrix\n    self.distortion_coefficients = distortion_coefficients\n</code></pre>"},{"location":"modules/#pupil_labs.camera.CameraRadial.optimal_camera_matrix","title":"optimal_camera_matrix  <code>cached</code> <code>property</code>","text":"<pre><code>optimal_camera_matrix: CameraMatrix\n</code></pre> <p>The \"optimal\" camera matrix for undistorting images.</p> <p>This method uses OpenCV's <code>getOptimalNewCameraMatrix</code> to calculate a new camera matrix that maximizes the retirval of sensible pixels in the undistortion process, while avoiding \"virtual\" black pixels stemming from outside the captured distorted image.</p>"},{"location":"modules/#pupil_labs.camera.CameraRadial.project_points","title":"project_points","text":"<pre><code>project_points(points_3d: Points3DLike, use_distortion: bool = True, use_optimal_camera_matrix: bool = False) -&gt; Points2D\n</code></pre> <p>Projects 3D points onto the 2D image plane using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_3d</code>               (<code>Points3DLike</code>)           \u2013            <p>Array of 3D point(s) to be projected.</p> </li> <li> <code>use_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies distortion using the camera's distortion coefficients. If False, ignores distortion.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses the optimal camera matrix for projection instead of the regular camera matrix.</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def project_points(\n    self,\n    points_3d: CT.Points3DLike,\n    use_distortion: bool = True,\n    use_optimal_camera_matrix: bool = False,\n) -&gt; CT.Points2D:\n    \"\"\"Projects 3D points onto the 2D image plane using the camera's intrinsics.\n\n    Args:\n        points_3d: Array of 3D point(s) to be projected.\n        use_distortion: If True, applies distortion using the camera's distortion\n            coefficients. If False, ignores distortion.\n        use_optimal_camera_matrix: If True, uses the optimal camera matrix for\n            projection instead of the regular camera matrix.\n\n    \"\"\"\n    points_3d = self._to_np_array(points_3d)\n\n    if not (\n        (points_3d.ndim == 2 and points_3d.shape[1] == 3)\n        or (points_3d.ndim == 1 and points_3d.shape[0] == 3)\n    ):\n        raise ValueError(\n            f\"points_3d should have shape `(N, 3)` or `(3,)`, got {points_3d.shape}\"\n        )\n\n    input_dim = points_3d.ndim\n    if input_dim == 1:\n        points_3d = points_3d[np.newaxis, :]\n\n    if use_distortion:\n        distortion_coefficients = self.distortion_coefficients\n    else:\n        distortion_coefficients = None\n\n    if use_optimal_camera_matrix:\n        camera_matrix = self.optimal_camera_matrix\n    else:\n        camera_matrix = self.camera_matrix\n\n    points_2d = opencv_funcs.project_points(\n        points_3d, camera_matrix, distortion_coefficients\n    ).reshape(-1, 2)\n\n    if input_dim == 1:\n        points_2d = points_2d[0]\n\n    return points_2d\n</code></pre>"},{"location":"modules/#pupil_labs.camera.CameraRadial.undistort_points","title":"undistort_points","text":"<pre><code>undistort_points(points_2d: Points2DLike, use_optimal_camera_matrix: bool = False) -&gt; Points2D\n</code></pre> <p>Undistorts 2D image points using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_2d</code>               (<code>Points2DLike</code>)           \u2013            <p>Array-like of 2D point(s) to be undistorted.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses the regular camera matrix for unprojection, and the optimal camera matrix for reprojection. If False, uses the regular camera matrix for both.</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def undistort_points(\n    self,\n    points_2d: CT.Points2DLike,\n    use_optimal_camera_matrix: bool = False,\n) -&gt; CT.Points2D:\n    \"\"\"Undistorts 2D image points using the camera's intrinsics.\n\n    Args:\n        points_2d: Array-like of 2D point(s) to be undistorted.\n        use_optimal_camera_matrix: If True, uses the *regular* camera matrix for\n            unprojection, and the optimal camera matrix for reprojection. If False,\n            uses the regular camera matrix for both.\n\n    \"\"\"\n    points_2d = self._to_np_array(points_2d)\n\n    if not (\n        (points_2d.ndim == 2 and points_2d.shape[1] == 2)\n        or (points_2d.ndim == 1 and points_2d.shape[0] == 2)\n    ):\n        raise ValueError(\n            f\"points_2d should have shape `(N, 2)` or `(2,)`, got {points_2d.shape}\"\n        )\n\n    input_dim = points_2d.ndim\n    if input_dim == 1:\n        points_2d = points_2d[np.newaxis, :]\n\n    if use_optimal_camera_matrix:\n        camera_matrix = self.optimal_camera_matrix\n    else:\n        camera_matrix = self.camera_matrix\n\n    points_undistorted = opencv_funcs.undistort_points(\n        points_2d, camera_matrix, self.distortion_coefficients, camera_matrix\n    ).reshape(-1, 3)\n\n    points_undistorted = (\n        points_undistorted[:, :2] / points_undistorted[:, 2, np.newaxis]\n    )\n\n    if input_dim == 1:\n        points_undistorted = points_undistorted[0]\n\n    return points_undistorted\n</code></pre>"},{"location":"modules/#pupil_labs.camera.CameraRadial.unproject_points","title":"unproject_points","text":"<pre><code>unproject_points(points_2d: Points2DLike, use_distortion: bool = True, use_optimal_camera_matrix: bool = False) -&gt; Points3D\n</code></pre> <p>Unprojects 2D image points to 3D space using the camera's intrinsics.</p> <p>Parameters:</p> <ul> <li> <code>points_2d</code>               (<code>Points2DLike</code>)           \u2013            <p>Array-like of 2D point(s) to be unprojected.</p> </li> <li> <code>use_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, applies distortion correction using the camera's distortion coefficients. If False, ignores distortion correction.</p> </li> <li> <code>use_optimal_camera_matrix</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses the optimal camera matrix for unprojection.</p> </li> </ul> Source code in <code>src/pupil_labs/camera/radial.py</code> <pre><code>def unproject_points(\n    self,\n    points_2d: CT.Points2DLike,\n    use_distortion: bool = True,\n    use_optimal_camera_matrix: bool = False,\n) -&gt; CT.Points3D:\n    \"\"\"Unprojects 2D image points to 3D space using the camera's intrinsics.\n\n    Args:\n        points_2d: Array-like of 2D point(s) to be unprojected.\n        use_distortion: If True, applies distortion correction using the camera's\n            distortion coefficients. If False, ignores distortion correction.\n        use_optimal_camera_matrix: If True, uses the optimal camera matrix for\n            unprojection.\n\n    \"\"\"\n    points_2d = self._to_np_array(points_2d)\n\n    if not (\n        (points_2d.ndim == 2 and points_2d.shape[1] == 2)\n        or (points_2d.ndim == 1 and points_2d.shape[0] == 2)\n    ):\n        raise ValueError(\n            f\"points_2d should have shape `(N, 2)` or `(2,)`, got {points_2d.shape}\"\n        )\n\n    input_dim = points_2d.ndim\n    if input_dim == 1:\n        points_2d = points_2d[np.newaxis, :]\n\n    if use_optimal_camera_matrix:\n        camera_matrix = self.optimal_camera_matrix\n    else:\n        camera_matrix = self.camera_matrix\n\n    if use_distortion:\n        distortion_coefficients = self.distortion_coefficients\n    else:\n        distortion_coefficients = None\n\n    points_3d = opencv_funcs.undistort_points(\n        points_2d, camera_matrix, distortion_coefficients, None\n    )\n\n    # Remove unnecessary dimension if input was a single point\n    if input_dim == 1:\n        points_3d = points_3d[0]\n\n    return points_3d\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}